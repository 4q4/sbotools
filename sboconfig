#!/usr/bin/env perl
#
# sboconfig
# script to handle sbotools configuration
#
# author: Jacob Pipkin <j@dawnrazor.net>
# date: Pungenday, the 40th day of Discord in the YOLD 3178
# license: WTFPL <http://sam.zoy.org/wtfpl/COPYING>

use strict;
use warnings FATAL => 'all';
use SBO::Lib;
use File::Basename;
use Getopt::Std;
use File::Copy;
use File::Path qw(make_path);
use Fcntl;

my %config = %SBO::Lib::config;
my $self = basename ($0);

sub show_usage {
	print <<EOF
Usage: $self [options] [arguments]

Options:
  -h: this screen.
  -v: version information.
  -l: show current options.

Config options (defaults shown):
  -c FALSE:
      NOCLEAN: if TRUE, do NOT clean up after building by default.
  -d FALSE:
      DISTCLEAN: if TRUE, DO clean distfiles by default after building.
  -j FALSE:
      JOBS: numeric -j setting to feed to make for multicore systems.
  -p FALSE:
      PKG_DIR: set a directory to store packages in. 
  -s /usr/sbo:
      SBO_HOME: set the SBo directory.

EOF
}

my %options;
getopts ('hvlc:d:p:s:j:', \%options);

show_usage () and exit (0) if exists $options{h};
show_version () and exit (0) if exists $options{v};

if (exists $options{l}) {
	my @keys = sort {$a cmp $b} keys %config;
	for my $key (@keys) {
		print "$key=$config{$key}\n";
	}
}

show_usage () unless %options;

my %valid_confs = (
	c => 'NOCLEAN',
	d => 'DISTCLEAN',
	j => 'JOBS',
	p => 'PKG_DIR',
	s => 'SBO_HOME',
);
	
my %changes;
while (my ($key, $value) = each %valid_confs) {
	$changes{$value} = $options{$key} if exists $options{$key};
}
if (exists $changes{JOBS}) {
	unless ($changes{JOBS} =~ /^\d+$/) {
		print "You have provided an invalid parameter for -j\n";
		exit 1;
	}
}

my $conf_dir = $SBO::Lib::conf_dir;;
my $conf_file = $SBO::Lib::conf_file;

sub config_write {
	script_error ('config_write requires two arguments.') unless exists $_[1];
	my ($key, $val) = @_;
	if (! -d $conf_dir) {
		mkdir ($conf_dir)
			or print "Unable to create $conf_dir. Exiting.\n" and exit (1);
	}
	if (-f $conf_file) {
		my ($fh, $filename) = make_temp_file ();
		open my $reader, '<', $conf_file;
		print {$fh} <$reader>;
		close ($fh);
		tie my @temp, 'Tie::File', $filename;
		my $has = 'FALSE';
		my $regex = qr/\A\Q$key\E=/;
		FIRST: for my $tmpline (@temp) {
			if ($tmpline =~ $regex) {
				$has = 'TRUE';
				$tmpline = "$key=$val";
				last FIRST;
			}
		}
		untie @temp;
		if ($has eq 'FALSE') {
			open (my $writer, '>>', $filename);
			print {$writer} "$key=$val\n";
			close ($writer);
		}
		move ($filename, $conf_file);
	} else {
		open my $writer, '>', $conf_file;
		print {$writer} "$key=$val\n";
		close ($writer);
	}
}

while (my ($key, $value) = each %changes) {
	print "Setting $key to $value...\n";
	config_write ($key, $value);
}

exit 0;
