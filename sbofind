#!/usr/bin/env perl
#
# vim: set ts=4:noet
#
# sbofind
# script to locate something in a local SlackBuilds tree.
#
# author: Jacob Pipkin <j@dawnrazor.net>
# license: WTFPL <http://sam.zoy.org/wtfpl/COPYING>

use 5.16.0;
use strict;
use warnings FATAL => 'all';
use SBO::Lib;
use File::Basename;
use Getopt::Long qw(:config bundling);

my $self = basename ($0);

sub show_usage () {
	print <<EOF
Usage: $self (search_term)

Options:
  -h|--help:
	this screen.
  -v|--verison:
	version information.
  -i|--info:
	show the .info for each found item.
  -r|--readme:
	show the README for each found item.
  -q|--queue:
	show the build queue for each found item.

Example:
  $self libsexy 

EOF
}

my ($help, $vers, $show_info, $show_readme, $show_queue);

GetOptions (
	'help|h'    => \$help,
	'version|v' => \$vers,
	'info|i'    => \$show_info,
	'readme|r'  => \$show_readme,
	'queue|q'   => \$show_queue,
);

show_usage and exit 0 if $help;
show_version and exit 0 if $vers;

show_usage and exit 1 unless exists $ARGV[0];
my $search = $ARGV[0];

# if we can't find SLACKBUILDS.TXT in $config{HOME}, prompt to fetch the tree
slackbuilds_or_fetch;

# find anything with $search in its name
sub perform_search ($) {
	exists $_[0] or script_error 'perform_search requires an argument.';
	my $search = shift;
	my (@findings, $name, $found);
	my $name_regex = qr/NAME:\s+(.*\Q$search\E.*)$/i;
	my $loc_regex = qr/LOCATION:\s+(.*)$/;
	my $fh = open_read "$config{SBO_HOME}/SLACKBUILDS.TXT";
	FIRST: while (my $line = <$fh>) {
		unless ($found) {
			$found++, next FIRST if $name = ($line =~ $name_regex)[0];
		} else {
			if (my ($location) = ($line =~ $loc_regex)[0]) {
				$found = 0;
				$location =~ s#^\.##;
				push @findings, {$name => $config{SBO_HOME} . $location};
			}
		}
	}
	return \@findings;
}

# pull the contents of a file into a variable and format it for output
sub get_file_contents ($) {
	exists $_[0] or script_error 'get_file_contents requires an argument';
	-f $_[0] or return "$_[0] doesn't exist.\n";
	my $fh = open_read shift;
	my $contents = do {local $/; <$fh>};
	for ($contents) {
		s/\n/\n        /g;
		s/\n        $//g;
	}
	return $contents;
}

# get full build queue and prepare it for output.
sub get_build_queue ($) {
	exists $_[0] or script_error 'get_build_queue requires an argument.';
	my @temp_queue = ();
	my @build_queue = ();
	my %seen = ();
	&add_to_queue(\@temp_queue,"$_[0]",1);
	@temp_queue = reverse(@temp_queue);
	# Remove duplicate entries (leaving first occurance)
	for my $sb( @temp_queue ) {
		 next if $seen{ $sb }++;
		 push @build_queue, $sb;
	}    
	return join(" ", @build_queue);
}

# add slackbuild to build queue.
# args: @queue(array), $sbname(string), $recursive(boolean) 
sub add_to_queue () {
	my $queue = \@{$_[0]};
	my $sbname = $_[1];
	my $recursive = $_[2];
	my $sbpath = get_sbo_location($sbname);
	push(@{$queue}, $sbname);
	return 1 unless $recursive; 
	for my $line (split("\n", get_file_contents("$sbpath/$sbname.info"))) {
		if ($line =~ /REQUIRES="(.*?)"/) {
			for my $req (split(" ", $1)) {
				&add_to_queue($queue,"$req",1) unless ( $req eq "%README%" );
			}
		}
	}
}

my $findings = perform_search $search;

# pretty formatting
if (exists $$findings[0]) {
	my @listing = ("\n");
	for my $hash (@$findings) {
		while (my ($key, $val) = each %$hash) {
			say "SBo:    $key";
			say "Path:   $val";
			say "info:   ". get_file_contents "$val/$key.info" if $show_info;
			say "README: ". get_file_contents "$val/README" if $show_readme;
			say "Queue:  ". get_build_queue "$key" if $show_queue;
			say '';
		}
	}
} else {
	say "Nothing found for search term: $search";
}

exit 0;
