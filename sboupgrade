#!/usr/bin/env perl
#
# vim: set ts=4:noet
#
# sboupgrade
# script to update an installed SlackBuild.
#
# author: Jacob Pipkin <j@dawnrazor.net>
# date: Boomtime, the 39th day of Discord in the YOLD 3178
# license: WTFPL <http://sam.zoy.org/wtfpl/COPYING>

use 5.16.0;
use SBO::Lib;
use File::Basename;
use Getopt::Std;
use File::Copy;
use strict;
use warnings FATAL => 'all';

my %config = %SBO::Lib::config;
my $self = basename ($0);

sub show_usage () {
	print <<EOF
Usage: $self (options) [package]

Options:
  -h: this screen.
  -v: version information.
  -c: do not clean working files/directories after the build.
  -d: clean distfiles afterward.
  -f: force an update, even if the "upgrade" version is the same or lower.
  -i: do not run installpkg at the end of the build process.
  -j: specify "-j" setting to make, for multicore systems; overrides conf file.
  -N: install any new SBo's listed.
  -r: skip viewing of the SBo README.
  -R: view the README but do not attempt to parse requirements.

Example:
  $self -d libsexy
  $self -ca

EOF
}

my %options;
getopts ('hvacdfj:NriopR', \%options);

show_usage && exit 0 if exists $options{h};
show_version && exit 0 if exists $options{v};
my $noclean = exists $options{c} ? 'TRUE' : $config{NOCLEAN};
my $distclean = exists $options{d} ? 'TRUE' : $config{DISTCLEAN};
my $force = exists $options{f} ? 1 : 0;
my $install_new = exists $options{N} ? 1 : 0;
my $no_readme = exists $options{r} ? 1 : 0;
my $no_install = exists $options{i} ? 1 : 0;
my $only_new = exists $options{o} ? 1 : 0;
my $compat32 = exists $options{p} ? 1 : 0;
my $no_reqs = exists $options{R} ? 1 : 0;

if (exists $options{j}) {
	die "You have provided an invalid parameter for -j\n" unless
		($options{j} =~ /^\d+$/ || $options{j} eq 'FALSE');
}
my $jobs = exists $options{j} ? $options{j} : $config{JOBS};

show_usage and exit 1 unless exists $ARGV[0];

# if we can't find SLACKBUILDS.TXT in $config{HOME}, prompt to fetch the tree
slackbuilds_or_fetch; 

# build a hash of locations for each item provided on command line, at the same
# time verifying each item is a valid slackbuild
my %locations;
for my $sbo_name (@ARGV) {
	$locations{$sbo_name} = get_sbo_location $sbo_name;
	die "Unable to locate $sbo_name in the SlackBuilds.org tree.\n" unless
		defined $locations{$sbo_name};
}

sub get_readme_path ($) {
	exists $_[0] or script_error 'get_readme_path requires an argument.';
	my $sbo = shift;
	return $locations{$sbo} .'/README';
}

# for a ref to an array of hashes of installed packages, return an array ref
# consisting of just their names
sub get_inst_names ($) {
	exists $_[0] or script_error 'get_inst_names requires an argument.';
	my $inst = shift;
	my $installed;
	push @$installed, $$_{name} for @$inst;
	return $installed;
}

# pull list of requirements, offer to install them
sub grok_requirements ($$$) {
	exists $_[1] or script_error 'grok_requirements requires an argument.';
	my ($sbo, $location, $readme) = @_;
	my $requires = get_from_info (LOCATION => $location, GET => 'REQUIRES');
	return unless $$requires[0];
	for my $req (@$requires) {
		my $inst = get_installed_sbos;
		my $inst_names= get_inst_names $inst;;
		unless ($req ~~ @$inst_names) {
			say $readme;
			say "$sbo has $req listed as a requirement.";
			print "Shall I attempt to install it first? [y] ";
			if (<STDIN> =~ /^[Yy\n]/) {
				my @cmd = ('/usr/sbin/sboupgrade', '-oN', $req);
				system (@cmd) == 0 or die "$req failed to install.\n";
			}
		}
	}
	return 1;
}

# look for any (user|group)add commands in the README
sub grok_user_group ($) {
	exists $_[0] or script_error 'grok_user_group requires an argument';
	my $readme = shift;
	my $readme_array = [split /\n/, $readme];
	my $cmd_regex = qr/^\s*#\s+((user|group)add.*)/;
	my @cmds;
	push @cmds, ($_ =~ $cmd_regex)[0] for @$readme_array;
	return unless exists $cmds[0];
	say "\n". $readme;
	print "\nIt looks like this slackbuild requires the following command(s)";
	say " to be run first:";
	say "    # $_" for @cmds;
	print "Shall I run it/them now? [y] ";
	if (<STDIN> =~ /^[Yy\n]/) {
		for my $cmd (@cmds) {
			system ($cmd == 0) or warn "\"$cmd\" exited non-zero\n";
		}
	}
	return 1;
}

# see if the README mentions any options
sub grok_options ($) {
	exists $_[0] or script_error 'grok_options requires an argument';
	my $readme = shift;
	return unless $readme =~ /[A-Z]+=[^\s]/;
	say "\n". $readme;
	print "\nIt looks this slackbuilds has options; would you like to set any";
	print " when the slackbuild is run? [n] ";
	if (<STDIN> =~ /^[Yy]/) {
		my $ask = sub () {
			print "\nPlease supply any options here, or enter to skip: ";
			chomp (my $opts = <STDIN>);
			return if $opts =~ /^$/;
			return $opts;
		};
		my $kv_regex = qr/[A-Z]+=[^\s]+(|\s([A-Z]+=[^\s]+){0,})/;
		my $opts = &$ask; 
		FIRST: while ($opts !~ $kv_regex) {
			warn "Invalid input received.\n";
			$opts = &$ask; 
		}
		return $opts;
	}
	return;
}

# prompt for the readme
sub readme_prompt ($$) {
	exists $_[0] or script_error 'readme_prompt requires an argument.';
	my ($sbo, $location) = @_;
	my $fh = open_read (get_readme_path $sbo);
	my $readme = do {local $/; <$fh>};
	close $fh;
	# check for requirements, useradd/groupadd, options
	grok_requirements $sbo, $location, $readme;
	grok_user_group $readme;
	my $opts = grok_options $readme;
	print "\n". $readme unless $opts;
	# present the name as -compat32 if appropriate
	my $name = $compat32 ? "$sbo-compat32" : $sbo;
	print "\nProceed with $name? [y]: ";
	exit 0 unless <STDIN> =~ /^[Yy\n]/;
	return $opts;
}

# do the things with the provided sbos - whether upgrades or new installs.
sub process_sbos {
	exists $_[0] or script_error 'process_sbos requires an argument.';
	my $todo = shift;
	my @failures;
	FIRST: for my $sbo (keys %$todo) {
		my $opts = 0;
		$opts = readme_prompt $sbo, $$todo{$sbo} unless $no_readme;
		# switch compat32 on if upgrading a -compat32
		$compat32 = 1 if $sbo =~ /-compat32$/;
		my ($version, $pkg, $src);
		eval { ($version, $pkg, $src) = do_slackbuild (
			OPTS		=> $opts,
			JOBS		=> $jobs,
			LOCATION	=> $locations{$sbo},
			COMPAT32	=> $compat32,
		); };
		if ($@) {
			push @failures, $sbo;
		} else {
			unless ($distclean eq 'TRUE') {
				make_clean $sbo, $src, $version unless $noclean eq 'TRUE';
			} else {
				make_distclean (
					SBO			=> $sbo,
					SRC			=> $src,
					VERSION		=> $version,
					LOCATION	=> $locations{$sbo},
				);
			}
			do_upgradepkg $pkg unless $no_install;
			# move package to $config{PKG_DIR} if defined
			unless ($config{PKG_DIR} eq 'FALSE') {
				my $dir = $config{PKG_DIR};
				unless (-d $dir) {
					mkdir ($dir) or warn "Unable to create $dir\n";
				}
				if (-d $dir) {
					move ($pkg, $dir), say "$pkg stored in $dir";
				} else {
					warn "$pkg left in /tmp\n";
				}
			} elsif ($distclean eq 'TRUE') {
				unlink ($pkg);
			}
		}
	}
	return @failures;
}

sub print_failures (;@) {
	if (exists $_[0]) {
		say "Failures:";
		say "  $_" for @_;
		exit 1;
	}
}

# deal with any updates prior to any new installs.
# no reason to bother if only_new is specified, ie running from sboinstall.
goto INSTALL_NEW if $only_new;

# doesn't matter what's updatable and what's not if force is specified
my @updates unless $force;
unless ($force) {
	my $updates = get_available_updates; 
	push @updates, $$_{name} for @$updates;
}
my $todo_upgrade;
# but without force, we only want to update what there are updates for
unless ($force) {
	for my $sbo (@ARGV) {
		$$todo_upgrade{$sbo} = $locations{$sbo} if $sbo ~~ @updates;
	}
} else {
	my $inst = get_installed_sbos; 
	my $inst_names= get_inst_names $inst;;
	FIRST: for my $sbo (@ARGV) {
		if ($sbo ~~ @$inst_names) {
			$$todo_upgrade{$sbo} = $locations{$sbo};
		}
	}
}
my @failures = process_sbos $todo_upgrade if keys %$todo_upgrade > 0;
print_failures @failures;

INSTALL_NEW:
exit 0 unless $install_new;
my $todo_install;
FIRST: for my $sbo (@ARGV) {
	my $name = $compat32 ? "$sbo-compat32" : $sbo;
	my $inst = get_installed_sbos; 
	my $inst_names = get_inst_names $inst;;
	warn "$name already installed\n", next FIRST if $name ~~ @$inst_names;
	# if compat32 is TRUE, we need to see if the non-compat version exists.
	if ($compat32) {
		my $inst = get_installed_sbos; 
		my $inst_names = get_inst_names $inst;
		unless ($sbo ~~ @$inst_names) {
			print "\nYou are attempting to install $name, however, $sbo is not";
			print " yet installed. Shall I install it first? [y] ";
			if (<STDIN> =~ /^[Yy\n]/) {
				my @args = ('/usr/sbin/sboupgrade', '-oN', $sbo);
				system (@args) == 0 or exit 1;
			} else {
				warn "Please install $sbo\n" and exit 0;
			}
		}
	}
	$$todo_install{$sbo} = $locations{$sbo};
}
@failures = process_sbos $todo_install if keys %$todo_install > 0;
print_failures @failures;

exit 0;
