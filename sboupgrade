#!/usr/bin/env perl
#
# sboupgrade
# script to update an installed SlackBuild.
#
# author: Jacob Pipkin <j@dawnrazor.net>
# date: Boomtime, the 39th day of Discord in the YOLD 3178
# license: WTFPL <http://sam.zoy.org/wtfpl/COPYING>

use SBO::Lib;
use File::Basename;
use Getopt::Std;
use Text::Tabulate;
use File::Copy;
use strict;
use warnings FATAL => 'all';

my %config = %SBO::Lib::config;
my $self = basename ($0);

sub show_usage {
	print <<EOF
Usage: $self (options) [package]

Options:
  -h: this screen.
  -v: version information.
  -c: do not clean working files/directories after the build.
  -d: clean distfiles afterward.
  -f: force an update, even if the "upgrade" version is the same or lower.
  -i: do not run installpkg at the end of the build process.
  -j: specify "-j" setting to make, for multicore systems; overrides conf file.
  -N: install any new SBo's listed.
  -r: skip viewing of the SBo README.

Example:
  $self -d libsexy
  $self -ca

EOF
}

my %options;
getopts ('hvacdfj:Nriop', \%options);

show_usage () && exit (0) if exists $options{h};
show_version () && exit (0) if exists $options{v};
my $noclean = exists $options{c} ? 'FALSE' : $config{NOCLEAN};
my $distclean = exists $options{d} ? 'TRUE' : $config{DISTCLEAN};
my $force = exists $options{f} ? 'TRUE' : 'FALSE';
my $install_new = exists $options{N} ? 'TRUE' : 'FALSE';
my $no_readme = exists $options{r} ? 'TRUE' : 'FALSE';
my $no_install = exists $options{i} ? 'TRUE' : 'FALSE';
my $only_new = exists $options{o} ? 'TRUE' : 'FALSE';
my $compat32 = exists $options{p} ? 'TRUE' : 'FALSE';

if (exists $options{j}) {
	unless ($options{j} =~ /^\d+$/) {
		print "You have provided an invalid parameter for -j\n";
		exit 1;
	}
}
my $jobs = exists $options{j} ? $options{j} : $config{JOBS};

show_usage () and exit (1) unless exists $ARGV[0];

slackbuilds_or_fetch ();

my %locations;

for my $sbo_name (@ARGV) {
	$locations{$sbo_name} = get_sbo_location ($sbo_name);
	unless (defined $locations{$sbo_name}) {
		print "Unable to locate $sbo_name in the SlackBuilds.org tree.\n";
		exit 1;
	}
}

sub get_readme_path {
	script_error ('get_readme_path requires an argument.') unless exists $_[0];
	my $sbo = shift;
	my $location = $locations{$sbo};
	return $location .'/README';
}

sub grok_readme {
	script_error ('grok_readme requires two arguments') unless exists $_[1];
	my ($sbo, $readme) = @_;
	$readme =~ s/\n//g;
	my @line;
	unless (@line = $readme =~ /([Tt]his|$sbo|)\s+[Rr]equires(|:)\s+([^\.]+)/) {
		return;
	}
	my $string = $line[2];
	$string =~ s/\[[^\]]+\]//g;
	$string =~ s/\([^\)]+\)//g;
	$string =~ s/\s+and\s+/,/g;
	$string =~ s/,\s+/,/g;
	my @deps = split (/,/, $string);
	my @installed = get_installed_sbos ();
	my @needed;
	my @have;
	FIRST: for my $dep (@deps) {
		SECOND: for my $c (keys @installed) {
			if ($dep eq $installed[$c]{name}) {
				push (@have, $dep);
				last SECOND;
			}
		}
	}
	for my $dep (@deps) {
		push (@needed, $dep) unless $dep ~~ @have;
	}
	FIRST: for my $need (@needed) {
		my @inst = get_installed_sbos ();
		SECOND: for my $c (keys @inst) {
			next FIRST if $need eq $inst[$c]{name};
		}
		print "It looks this slackbuild requires $need; shall I attempt to ";
		print "install it first? [y] ";
		my $test = <STDIN>;
		$test = 'y' if $test eq "\n";
		system ("/usr/sbin/sboinstall $need") if $test =~ /^[Yy]/;
	}
}

sub readme_prompt {
	script_error ('readme_prompt requires an argument.') unless exists $_[0];
	my $sbo = shift;
	my $readme_path = get_readme_path ($sbo);
	open my $readme_file, '<', $readme_path;
	my $readme = do {local $/; <$readme_file>};
	print "\n". $readme;
	unless (grok_readme ($sbo, $readme) ) {
		close ($readme_file);
		print "\nProceed with $sbo? [y]: ";
		my $test = <STDIN>;
		$test = 'y' if $test eq "\n";
		exit (0) unless $test =~ /^[Yy]/;
		return 1;
	}
}

sub process_sbos {
	script_error ('process_sbos requires an argument.') unless exists $_[0];
	my @todo = @_;
	my @failures;
	for my $sbo (@todo) {
		readme_prompt ($sbo) unless $no_readme eq 'TRUE';
		$compat32 = 'TRUE' if $sbo =~ /-compat32$/;
		my $version;
		my $pkg;
		eval {
			($version,$pkg) = do_slackbuild
				($jobs, $sbo, $locations{$sbo}, $compat32);
		};
		if ($@) {
			push (@failures, $sbo);
		} else {
			unless ($distclean eq 'TRUE') {
				if ($noclean eq 'FALSE') {
					make_clean ($sbo, $version);
				}
			} else {
				make_distclean ($sbo, $version, $locations{$sbo});
			}
			do_upgradepkg ($pkg) unless $no_install eq 'TRUE';

			unless ($config{PKG_DIR} eq 'FALSE') {
				unless (-d $config{PKG_DIR}) {
					mkdir ($config{PKG_DIR}) or 
						warn "Unable to create $config{PKG_DIR}\n";
				}
				if (-d $config{PKG_DIR}) {
					move ($pkg, $config{PKG_DIR});
					print "$pkg stored in $config{PKG_DIR}\n";
				} else {
					warn "$pkg left in /tmp\n";
				}
			} elsif ($distclean eq 'TRUE') {
				unlink ($pkg);
			}
		}
	}
	return @failures;
}

my @installed = get_installed_sbos ();
my @failed;

sub print_failures {
	if (exists $failed[0]) {
		print "Failures:\n";
		print "  $_\n" for (@failed);
		exit 1;
	}
}

unless ($only_new eq 'TRUE') {
	my @updates unless $force eq 'TRUE';
	unless ($force eq 'TRUE') {
		my @updates_array = get_available_updates ();
		for my $index (keys @updates_array) {
			push(@updates, $updates_array[$index]{name});
		}
	}

	my @todo_upgrade;
	unless ($force eq 'TRUE') {
		for my $sbo (@ARGV) {
			if ($sbo ~~ @updates) {
				push (@todo_upgrade, $sbo);
			}
		}
	} else {
		FIRST: for my $sbo (@ARGV) {
			SECOND: for my $c (keys @installed) {
				if ($sbo eq $installed[$c]{name}) {
					push (@todo_upgrade, $sbo);
					last SECOND;
				}
			}
		}
	}

	@failed = process_sbos (@todo_upgrade) if exists $todo_upgrade[0];
	print_failures () unless $install_new eq 'TRUE';
}

if ($install_new eq 'TRUE') {
	my @todo_install;
	my $has = 'FALSE';
	FIRST: for my $sbo (@ARGV) {
		my $name = $compat32 eq 'TRUE' ? "$sbo-compat32" : $sbo;
		SECOND: for my $index (keys @installed) {
			if ($name eq $installed[$index]{name}) {
				$has = 'TRUE';
				last SECOND;
			}
		}
		unless ($has eq 'TRUE') {
			push (@todo_install, $sbo);
		} else {
			print "$name already installed.\n";
		}
		$has = 'FALSE';
	}
	@failed = process_sbos (@todo_install) if exists $todo_install[0];
	print_failures ();
}

exit 0;
