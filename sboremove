#!/usr/bin/env perl
#
# vim: set ts=4:noet
#
# sboremove
# script to remove an installed SlackBuild and any unused dependencies
#
# author: Luke Williams <xocel@iquidus.org>
# license: WTFPL <http://sam.zoy.org/wtfpl/COPYING>

use 5.16.0;
use strict;
use warnings FATAL => 'all';
use SBO::Lib;
use Getopt::Long qw(:config bundling);
use File::Basename;

my $self = basename ($0);

sub show_usage () {
	print <<EOF
Usage: $self [options] sbo

Options (defaults shown first where applicable):
  -h|--help:
    this screen.
  -v|--version:
    version information.
  -r|--nointeractive:
    non-interactive; skips all prompts.
  -R|--norequirements:
    do not parse requirements.
  -f|--force:
    force remove, even if required by other packages on system.

Note: optional dependencies need to be removed separately. 

EOF
}



my ($help, $vers, $non_int, $no_reqs, $force, @excluded);

GetOptions (
	'help|h'		=> \$help,
	'version|v'		=> \$vers,
	'nointeractive|r'	=> \$non_int,
	'norequirements|R'	=> \$no_reqs,
	'force|f'		=> \$force,
);

show_usage and exit 0 if $help;
show_version and exit 0 if $vers;
show_usage and exit 0 unless exists $ARGV[0];

my $rootpkg = $ARGV[0];
my $test = get_sbo_location $rootpkg;
die "Unable to locate $rootpkg in the SlackBuilds.org tree.\n" unless
	defined $test;

my $remove_queue;
my %required_by;
my @confirmed;

sub get_requires ($) {
	my $location = get_sbo_location($_[0]);
	my $requires = get_from_info (LOCATION => $location, GET => 'REQUIRES');
	return $requires;
}

sub get_required_by ($) {
	my $pkg = $_[0];
	my @dep_of = ();
	if ( $required_by{$pkg} ) {
		for my $req_by (@{$required_by{$pkg}}) {
			unless ($req_by ~~ @confirmed) {
				push (@dep_of, $req_by);
			}
		}
	}
	return join(" ", @dep_of);
}

sub confirm_remove ($) {
	unless ($_[0] ~~ @confirmed) {
		push(@confirmed, $_[0]);
	}
}
# Determine dependencies of root package
unless ($no_reqs) {
	$remove_queue = get_build_queue($rootpkg);
	@$remove_queue = reverse(@$remove_queue);
} else {
	push(@$remove_queue, $rootpkg);
}

my $inst_names;
# Determine required by for all installed sbo's
unless ($force) {
	my $installed = get_installed_sbos;
	$inst_names = get_inst_names $installed;
	for my $inst (@$inst_names) {
		my $requires = get_requires "$inst";
		next unless $$requires[0];
		for my $req (@$requires) {
			unless ( $req eq "%README%" ) {
				if ( $req ~~ $inst_names ) {
					push(@{$required_by{$req}}, $inst);
				}
			}		
		}	
	}
}

# Make sure packages in remove queue are installed on system. 
my @temp;
if ($inst_names) {
	for my $i (@$remove_queue) {
		if ($i ~~ $inst_names) {
			push(@temp, $i);
		}
	}
	$remove_queue = \@temp;
}
if ( $non_int) {
	my $ignore;
	for my $pkg (@$remove_queue) {
		$ignore = 0;
		while ( my ($key, $value) = each(%required_by) ) {
			if ( $key eq $pkg ) {
	      			for my $v (@$value) {
	        			unless ($v ~~ @confirmed) {
	          				$ignore = 1;
	        			}
	      			}
	    		}
	  	}
	  	unless ($ignore) {
	    		confirm_remove $pkg;
	  	}
	}
} else {
	for my $pkg (@$remove_queue) {
		say $pkg;
		my $req_by_line = get_required_by $pkg;
		my $default = "y";
		if ( $req_by_line ) {
			say "required by : $req_by_line";
			$default = "n"; 
		}
		print "Remove? [$default] : ";
		my $userin = <STDIN>;
		chomp($userin);
		$userin = $default unless $userin;
		if ($userin =~ /^[Yy]/) {
			confirm_remove $pkg;
			say "* added $pkg to remove queue\n";
		} else {
			say "* ignoring $pkg\n"
		}
	}
}
# Show remove queue
my $remove_count = @confirmed;
if ($remove_count) {
	say "Removing $remove_count package(s)";
	for my $pkg (@confirmed) {
		print "$pkg ";
	}
	say "\n";	
} else {
	say "Nothing to remove.";
	exit 0;
}
unless ($non_int) {
	print 'Do you wish to proceed? [n] ';
	unless (<STDIN> =~ /^[Yy]/) {
		say "Exiting.";
		exit 0;
	}
}
	
for my $instpkg (@confirmed) {
	system("/sbin/removepkg $instpkg");
}

say "All operations completed successfully."
